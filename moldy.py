import pandas as pdimport cv2import matplotlib.pyplot as pltimport osimport timefrom math import sin, cosdef renderBeads(beadOutput="beadOutput.txt"):    """        A simple display function. Reads the bead output from moldy and renders    images of only the beads from the simulation    Parameters    ----------    beadOutput : str, optional        Should be left unchanged unless the user is providing their own bead         output file. The default is "beadOutput.txt".    Returns    -------    imgArr : array        Array of images for passing to the video creator function.    """    timeStart = time.time()    print("Generating image frames...")    imgArr = []    outputData = pd.read_csv("beadOutput.txt", sep=' ')    outputData1 = outputData.loc[outputData["ID"]==0]    noBeads = outputData["ID"].max() + 1    for i in range(0,outputData1.shape[0]):        fig, (XY, XZ) = plt.subplots(2,sharex=True,figsize=(5, 10))        for n in range(0,noBeads):            printData = outputData.loc[outputData["ID"]==n]            X = printData["X"].iloc[i]            Y = printData["Y"].iloc[i]            Z = printData["Z"].iloc[i]            beadXY = plt.Circle([X,Y],                               printData["Radius"].iloc[i], color="red",alpha=0.5)            beadXZ = plt.Circle([X,Z],                               printData["Radius"].iloc[i], color="red",alpha=0.5)                        XY.add_patch(beadXY)            XZ.add_patch(beadXZ)        XY.set_xlim([-5e-6,+5e-6])        XY.set_ylim([-5e-6,+5e-6])        XZ.set_xlim([-5e-6,+5e-6])        XZ.set_ylim([-5e-6,+5e-6])                XY.tick_params("both",direction='in')        XY.tick_params("both",direction='in')                XY.set_ylabel("Y (m)", fontsize=11)        XZ.set_ylabel("Z (m)")        XZ.set_xlabel("X (m)")        XY.set_aspect('equal')        XZ.set_aspect('equal')                fig.tight_layout()        plt.xlim(-5e-6,+5e-6)        plt.ylim(-5e-6,+5e-6)        plt.savefig("./graphicsOutput/images/frame"+str(i)+".png")        imgArr.append(cv2.imread("./graphicsOutput/images/frame"+str(i)+".png"))        plt.close()        plt.clf()    timeEnd = time.time()    print("> %dm %.6fs" % ((timeEnd-timeStart)//60,(timeEnd-timeStart)%60))    return imgArrdef renderBeadsSprings(beadOutput="beadOutput.txt",springOutput="springOutput.txt"):        timeStart = time.time()    print("Generating image frames...")    imgArr = []    outputDataBeads = pd.read_csv("beadOutput.txt", sep=' ')    outputDataSprings = pd.read_csv("springOutput.txt", sep=' ')    outputData1 = outputDataBeads.loc[outputDataBeads["ID"]==0]    noBeads = outputDataBeads["ID"].max() + 1    noSprings = outputDataSprings["ID"].max() + 1        maxForce = outputDataSprings["Force"].max()        Xbounds = [outputDataBeads["X"].min(), outputDataBeads["X"].max()]    Ybounds = [outputDataBeads["Y"].min(), outputDataBeads["Y"].max()]    Zbounds = [outputDataBeads["Z"].min(), outputDataBeads["Z"].max()]    maxBeadRadius = outputDataBeads["Radius"].max()    overallMin = min(Xbounds[0],Ybounds[0],Zbounds[0]) - maxBeadRadius    overallMax = max(Xbounds[1],Ybounds[1],Zbounds[1]) + maxBeadRadius        for i in range(0,outputData1.shape[0]):        fig, (XY, XZ) = plt.subplots(2,sharex=True,figsize=(5, 10))        for b in range(0,noBeads):            printData = outputDataBeads.loc[outputDataBeads["ID"]==b]            X = printData["X"].iloc[i]            Y = printData["Y"].iloc[i]            Z = printData["Z"].iloc[i]            beadXY = plt.Circle([X,Y],                               printData["Radius"].iloc[i], color="b",alpha=0.75,                              linewidth=3)            beadXY.set_ec("k")            beadXZ = plt.Circle([X,Z],                               printData["Radius"].iloc[i], color="b",alpha=0.75,                              linewidth=3)            beadXZ.set_ec("k")            XY.add_patch(beadXY)            XZ.add_patch(beadXZ)                    for s in range(0,noSprings):            printData = outputDataSprings.loc[outputDataSprings["ID"]==s]            startInd = printData["Start"].iloc[i]            endInd = printData["End"].iloc[i]                        beadStartData = outputDataBeads.loc[outputDataBeads["ID"]==startInd]            beadEndData = outputDataBeads.loc[outputDataBeads["ID"]==endInd]                        startX = beadStartData["X"].iloc[i]            startY = beadStartData["Y"].iloc[i]            startZ = beadStartData["Z"].iloc[i]                        endX = beadEndData["X"].iloc[i]            endY = beadEndData["Y"].iloc[i]            endZ = beadEndData["Z"].iloc[i]                        forceOverMax = printData["Force"].iloc[i]/maxForce                        springXY = plt.Line2D([startX,endX],[startY,endY],                                   color=[forceOverMax,0,0],                                  linewidth=3,                                  marker='o')            springXZ = plt.Line2D([startX,endX],[startZ,endZ],                                   color=[forceOverMax,0,0],                                  linewidth=3,                                  marker='o')            springXY.set_zorder(1)            springXZ.set_zorder(1)            XY.add_line(springXY)            XZ.add_line(springXZ)                                XY.set_xlim([overallMin,overallMax])        XY.set_ylim([overallMin,overallMax])        XZ.set_xlim([overallMin,overallMax])        XZ.set_ylim([overallMin,overallMax])                XY.tick_params("both",direction='in')        XY.tick_params("both",direction='in')                XY.set_ylabel("Y (m)", fontsize=11)        XZ.set_ylabel("Z (m)")        XZ.set_xlabel("X (m)")        XY.set_aspect('equal')        XZ.set_aspect('equal')                fig.tight_layout()        #plt.show()        plt.savefig("./graphicsOutput/images/frame"+str(i)+".png")        imgArr.append(cv2.imread("./graphicsOutput/images/frame"+str(i)+".png"))        plt.close()        plt.clf()    timeEnd = time.time()    print("> %dm %.6fs" % ((timeEnd-timeStart)//60,(timeEnd-timeStart)%60))    return imgArr   def imagesToVideo(imageArray, videoName = "video.mp4"):    timeStart = time.time()    print("Creating video from images...")    height,width,layers=imageArray[0].shape        fourcc = cv2.VideoWriter_fourcc(*'mp4v')     video = cv2.VideoWriter('./graphicsOutput/'+videoName,                            fourcc, 30, (width, height))        for img in imageArray:        video.write(img)    cv2.destroyAllWindows()    video.release()    timeEnd = time.time()    print("output: " + "./graphicsOutput/"+videoName)    print("> %dm %.6fs" % ((timeEnd-timeStart)//60,(timeEnd-timeStart)%60))    def runSimulation():    timeStart = time.time()    print("Running moldy...")    os.system("./moldy")    timeEnd = time.time()    print("> %dm %.6fs" % ((timeEnd-timeStart)//60,(timeEnd-timeStart)%60))def createBead(units="SI",position=[0,0,0],velocity=[0,0,0],mass=0,radius=0,charge=0):    if units == "SI":        bead = ("%e %e %e %e %e %e %e %e %e"                          %(position[0],position[1],position[2],                           velocity[0],velocity[1],velocity[2],                           mass, radius, charge))    return bead+'\n'def createSpring(units="SI",startInd=0,endInd=1,natLength=0,springConst=0):    if units == "SI":        spring = ("%d %d %e %e" % (startInd,endInd,natLength,springConst))    return spring+'\n'def createHomoChain(n,units="SI",position=[0,0,0],velocity=[0,0,0],                    mass=0,radius=0,charge=0,natLength=0,springConst=0):    beadArr = []    springArr = []    if units=="SI":        for i in range(0,n):            beadArr.append(createBead(position=[i*natLength,0,0],                                      velocity=[0,0,0],                                      mass=mass,                                      radius=radius,                                      charge=charge))            if i != 0:                springArr.append(createSpring(startInd=i-1,                                              endInd=i,                                              natLength=natLength,                                              springConst=springConst))                return beadArr, springArrdef createHomoLoop(n,units="SI",position=[0,0,0],velocity=[0,0,0],                    mass=0,radius=0,charge=0,natLength=0,springConst=0):    beadArr = []    springArr = []    d_theta = 2*3.14159/n    dist = radius/sin(d_theta/2)    if units=="SI":        for i in range(0,n):            beadArr.append(createBead(position=[dist*sin(i*d_theta),dist*cos(i*d_theta),0],                                      velocity=[0,0,0],                                      mass=mass,                                      radius=radius,                                      charge=charge))            if i != 0:                springArr.append(createSpring(startInd=i-1,                                              endInd=i,                                              natLength=natLength,                                              springConst=springConst))            else:                springArr.append(createSpring(startInd=i,                                              endInd=n-1,                                              natLength=natLength,                                              springConst=springConst))                return beadArr, springArr        def initialiseObjects(beadArray, springArray, io='w'):    with open("./beadInit.txt", io) as f:        for b in beadArray:            f.write(b)    with open("./springInit.txt", io) as f:        for s in springArray:            f.write(s)            def setSimulationParameters(maxTime,timestep,viscosity,temperature,                            overlapStrength):    with open("./simulationParameters.txt", 'w') as f:        f.write("%e %e %e %e %e" % (maxTime,timestep,viscosity,temperature,                                       overlapStrength))    beads, springs = createHomoLoop(32,mass=1e-9,radius=1e-6,charge=1e-6,                                 natLength=1.9e-6, springConst=1e-7)# beads, springs = createHomoLoop(20,mass=1e-9,radius=1e-6,charge=0,#                                  natLength=2e-6, springConst=1e-7)negBead = createBead(position=[0,0,0],mass=1e-8,radius=1e-6,charge=-1e-2)beads = beads + [negBead]setSimulationParameters(10,0.05,1e-3,300,5e-14)initialiseObjects(beads,springs)runSimulation()imageArray = renderBeadsSprings()imagesToVideo(imageArray)    