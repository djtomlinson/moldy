import pandas as pd #data managementimport cv2 #image and videoimport matplotlib.pyplot as plt #creating images (rendering)import os #file accessimport time #reporting code timingsfrom math import sin, cosdef renderBeads(beadOutput="beadOutput.txt"):    """        A simple display function. Reads the bead output from moldy and renders    images of only the beads from the simulation    Parameters    ----------    beadOutput : filepath, optional        Should be left unchanged unless the user is providing their own bead         output file. The default is "beadOutput.txt".    Returns    -------    imgArr : array        Array of images for passing to the video creator function.    """    timeStart = time.time()    print("Generating image frames...")    imgArr = []    outputData = pd.read_csv("beadOutput.txt", sep=' ')    outputData1 = outputData.loc[outputData["ID"]==0]    noBeads = outputData["ID"].max() + 1    for i in range(0,outputData1.shape[0]):        fig, (XY, XZ) = plt.subplots(2,sharex=True,figsize=(5, 10))        for n in range(0,noBeads):            printData = outputData.loc[outputData["ID"]==n]            X = printData["X"].iloc[i]            Y = printData["Y"].iloc[i]            Z = printData["Z"].iloc[i]            beadXY = plt.Circle([X,Y],                               printData["Radius"].iloc[i], color="red",alpha=0.5)            beadXZ = plt.Circle([X,Z],                               printData["Radius"].iloc[i], color="red",alpha=0.5)                        XY.add_patch(beadXY)            XZ.add_patch(beadXZ)        XY.set_xlim([-5e-6,+5e-6])        XY.set_ylim([-5e-6,+5e-6])        XZ.set_xlim([-5e-6,+5e-6])        XZ.set_ylim([-5e-6,+5e-6])                XY.tick_params("both",direction='in')        XY.tick_params("both",direction='in')                XY.set_ylabel("Y (m)", fontsize=11)        XZ.set_ylabel("Z (m)")        XZ.set_xlabel("X (m)")        XY.set_aspect('equal')        XZ.set_aspect('equal')                fig.tight_layout()        plt.xlim(-5e-6,+5e-6)        plt.ylim(-5e-6,+5e-6)        plt.savefig("./graphicsOutput/images/frame"+str(i)+".png")        imgArr.append(cv2.imread("./graphicsOutput/images/frame"+str(i)+".png"))        plt.close()        plt.clf()    timeEnd = time.time()    print("> %dm %.6fs" % ((timeEnd-timeStart)//60,(timeEnd-timeStart)%60))    return imgArrdef renderBeadsSprings(beadOutput="beadOutput.txt",springOutput="springOutput.txt"):        """        A simple display function. Reads the bead output from moldy and renders    images of beads and springs from the simulation    Parameters    ----------    beadOutput : filepath, optional        Should be left unchanged unless the user is providing their own bead         output file. The default is "beadOutput.txt".    springOutput : filepath, optional        Should be left unchanged unless the user is providing their own bead         output file. The default is "springOutput.txt".    Returns    -------    imgArr : array        Array of images for passing to the video creator function.    """    timeStart = time.time()    print("Generating image frames...")    imgArr = []    outputDataBeads = pd.read_csv("beadOutput.txt", sep=' ')    outputDataSprings = pd.read_csv("springOutput.txt", sep=' ')    outputData1 = outputDataBeads.loc[outputDataBeads["ID"]==0]    noBeads = outputDataBeads["ID"].max() + 1    noSprings = outputDataSprings["ID"].max() + 1        maxForce = outputDataSprings["Force"].max()        Xbounds = [outputDataBeads["X"].min(), outputDataBeads["X"].max()]    Ybounds = [outputDataBeads["Y"].min(), outputDataBeads["Y"].max()]    Zbounds = [outputDataBeads["Z"].min(), outputDataBeads["Z"].max()]    maxBeadRadius = outputDataBeads["Radius"].max()    overallMin = min(Xbounds[0],Ybounds[0],Zbounds[0]) - maxBeadRadius    overallMax = max(Xbounds[1],Ybounds[1],Zbounds[1]) + maxBeadRadius        for i in range(0,outputData1.shape[0]):        fig, (XY, XZ) = plt.subplots(2,sharex=True,figsize=(5, 10))        for b in range(0,noBeads):            printData = outputDataBeads.loc[outputDataBeads["ID"]==b]            X = printData["X"].iloc[i]            Y = printData["Y"].iloc[i]            Z = printData["Z"].iloc[i]            beadXY = plt.Circle([X,Y],                               printData["Radius"].iloc[i], color="b",alpha=0.75,                              linewidth=3)            beadXY.set_ec("k")            beadXZ = plt.Circle([X,Z],                               printData["Radius"].iloc[i], color="b",alpha=0.75,                              linewidth=3)            beadXZ.set_ec("k")            XY.add_patch(beadXY)            XZ.add_patch(beadXZ)                    for s in range(0,noSprings):            printData = outputDataSprings.loc[outputDataSprings["ID"]==s]            startInd = printData["Start"].iloc[i]            endInd = printData["End"].iloc[i]                        beadStartData = outputDataBeads.loc[outputDataBeads["ID"]==startInd]            beadEndData = outputDataBeads.loc[outputDataBeads["ID"]==endInd]                        startX = beadStartData["X"].iloc[i]            startY = beadStartData["Y"].iloc[i]            startZ = beadStartData["Z"].iloc[i]                        endX = beadEndData["X"].iloc[i]            endY = beadEndData["Y"].iloc[i]            endZ = beadEndData["Z"].iloc[i]                        forceOverMax = printData["Force"].iloc[i]/maxForce                        springXY = plt.Line2D([startX,endX],[startY,endY],                                   color=[forceOverMax,0,0],                                  linewidth=3,                                  marker='o')            springXZ = plt.Line2D([startX,endX],[startZ,endZ],                                   color=[forceOverMax,0,0],                                  linewidth=3,                                  marker='o')            springXY.set_zorder(1)            springXZ.set_zorder(1)            XY.add_line(springXY)            XZ.add_line(springXZ)                                XY.set_xlim([overallMin,overallMax])        XY.set_ylim([overallMin,overallMax])        XZ.set_xlim([overallMin,overallMax])        XZ.set_ylim([overallMin,overallMax])                XY.tick_params("both",direction='in')        XY.tick_params("both",direction='in')                XY.set_ylabel("Y (m)", fontsize=11)        XZ.set_ylabel("Z (m)")        XZ.set_xlabel("X (m)")        XY.set_aspect('equal')        XZ.set_aspect('equal')                fig.tight_layout()        #plt.show()        plt.savefig("./graphicsOutput/images/frame"+str(i)+".png")        imgArr.append(cv2.imread("./graphicsOutput/images/frame"+str(i)+".png"))        plt.close()        plt.clf()    timeEnd = time.time()    print("> %dm %.6fs" % ((timeEnd-timeStart)//60,(timeEnd-timeStart)%60))    return imgArr   def imagesToVideo(imageArray, videoName = "video.mp4"):    """    .mp4 video creator, taking image arrays as input. Video is created in the    graphicsOutput folder.    Parameters    ----------    imageArray : array        An array of images as created by the render...() functions.    videoName : string, optional        final name of video file, extension must be mp4.         The default is "video.mp4".    Returns    -------    None.    """    timeStart = time.time()    print("Creating video from images...")    height,width,layers=imageArray[0].shape        fourcc = cv2.VideoWriter_fourcc(*'mp4v')     video = cv2.VideoWriter('./graphicsOutput/'+videoName,                            fourcc, 30, (width, height))        for img in imageArray:        video.write(img)    cv2.destroyAllWindows()    video.release()    timeEnd = time.time()    print("output: " + "./graphicsOutput/"+videoName)    print("> %dm %.6fs" % ((timeEnd-timeStart)//60,(timeEnd-timeStart)%60))    def runSimulation():    """    Runs the moldy executable from python.    Returns    -------    None.    """    timeStart = time.time()    print("Running moldy...")    os.system("./moldy")    timeEnd = time.time()    print("> %dm %.6fs" % ((timeEnd-timeStart)//60,(timeEnd-timeStart)%60))def createBead(units="SI",position=[0,0,0],velocity=[0,0,0],mass=0,radius=0,charge=0):    """    Create a single bead with no connections.    Parameters    ----------    units : string, optional        Input units (only SI is currently supported). The default is "SI".    position : array, optional        bead starting position. The default is [0,0,0].    velocity : array, optional        bead starting velocity. The default is [0,0,0].    mass : float, optional        bead mass. The default is 0.    radius : float, optional        bead radius. The default is 0.    charge : float, optional        bead charge. The default is 0.    Returns    -------    str        string formatted correctly for sending to the initialisation file.    """    if units == "SI":        bead = ("%e %e %e %e %e %e %e %e %e"                          %(position[0],position[1],position[2],                           velocity[0],velocity[1],velocity[2],                           mass, radius, charge))    return bead+'\n'def createSpring(units="SI",startInd=0,endInd=1,natLength=0,springConst=0):    """    Create a spring between two beads by index.    Parameters    ----------    units : string, optional        Input units (only SI is currently supported). The default is "SI".    startInd : int, optional        index of the bead at one end of the spring. The default is 0.    endInd : int, optional        index of the bead at one end of the spring. The default is 0.    natLength : float, optional        Natural length of the spring. The default is 0.    springConst : float, optional        Hookean spring constant (spring stiffness). The default is 0.    Returns    -------    str        string formatted correctly for sending to the initialisation file.    """    if units == "SI":        spring = ("%d %d %e %e" % (startInd,endInd,natLength,springConst))    return spring+'\n'def createHomoChain(n,units="SI",position=[0,0,0],velocity=[0,0,0],                    mass=0,radius=0,charge=0,natLength=0,springConst=0):    """        Creates a chain of homogenous beads and spring (all beads have identical     qualities, all springs have identical qualities).    Parameters    ----------    n : int        Number of monomers (chain length).    units : string, optional        Input units (only SI is currently supported). The default is "SI".    position : array, optional        bead starting position. The default is [0,0,0].    velocity : array, optional        bead starting velocity. The default is [0,0,0].    mass : float, optional        bead mass. The default is 0.    radius : float, optional        bead radius. The default is 0.    charge : float, optional        bead charge. The default is 0.    natLength : float, optional        Natural length of the spring. The default is 0.    springConst : float, optional        Hookean spring constant (spring stiffness). The default is 0.    Returns    -------    beadArr : arr        array of formatted strings for sending to the simulation initialisation    springArr : arr        array of formatted strings for sending to the simulation initialisation    """    beadArr = []    springArr = []    if units=="SI":        for i in range(0,n):            beadArr.append(createBead(position=[i*natLength,0,0],                                      velocity=[0,0,0],                                      mass=mass,                                      radius=radius,                                      charge=charge))            if i != 0:                springArr.append(createSpring(startInd=i-1,                                              endInd=i,                                              natLength=natLength,                                              springConst=springConst))                return beadArr, springArrdef createHomoLoop(n,units="SI",position=[0,0,0],velocity=[0,0,0],                    mass=0,radius=0,charge=0,natLength=0,springConst=0):    """        Creates a loop of homogenous beads and spring (all beads have identical     qualities, all springs have identical qualities). I.E. polymer ends are     connected.    Parameters    ----------    n : int        Number of monomers (chain length).    units : string, optional        Input units (only SI is currently supported). The default is "SI".    position : array, optional        bead starting position. The default is [0,0,0].    velocity : array, optional        bead starting velocity. The default is [0,0,0].    mass : float, optional        bead mass. The default is 0.    radius : float, optional        bead radius. The default is 0.    charge : float, optional        bead charge. The default is 0.    natLength : float, optional        Natural length of the spring. The default is 0.    springConst : float, optional        Hookean spring constant (spring stiffness). The default is 0.    Returns    -------    beadArr : arr        array of formatted strings for sending to the simulation initialisation    springArr : arr        array of formatted strings for sending to the simulation initialisation    """    beadArr = []    springArr = []    d_theta = 2*3.14159/n    dist = radius/sin(d_theta/2)    if units=="SI":        for i in range(0,n):            beadArr.append(createBead(position=[dist*sin(i*d_theta),dist*cos(i*d_theta),0],                                      velocity=[0,0,0],                                      mass=mass,                                      radius=radius,                                      charge=charge))            if i != 0:                springArr.append(createSpring(startInd=i-1,                                              endInd=i,                                              natLength=natLength,                                              springConst=springConst))            else:                springArr.append(createSpring(startInd=i,                                              endInd=n-1,                                              natLength=natLength,                                              springConst=springConst))                return beadArr, springArr        def initialiseObjects(beadArray, springArray, io='w'):    """    Sends beads and springs to the simulation files prior to running the    simulation.    Parameters    ----------    beadArray : array        array of beads, generated from one of the creator files.    springArray : array        array of beads, generated from one of the creator files.    io : char, optional        method with which to open the initialisation files (clearing before        writing or just appending). The default is 'w'.    Returns    -------    None.    """    with open("./beadInit.txt", io) as f:        for b in beadArray:            f.write(b)    with open("./springInit.txt", io) as f:        for s in springArray:            f.write(s)            def setSimulationParameters(maxTime,timestep,viscosity,temperature,                            overlapStrength):    """    Set simulation parameters prior to running the simulation. Only required to    be called when simulation parameters are changed.    Parameters    ----------    maxTime : float        maximum time in simulated seconds the simulation will run up to.    timestep : float        dt in the simulation.    viscosity : float        viscosity of the medium in which the beads and springs exist.    temperature : float        simulation temperature.    overlapStrength : float        strength with which beads resist overlapping. User defined, high values        can affect the stability of the simulation.    Returns    -------    None.    """    with open("./simulationParameters.txt", 'w') as f:        f.write("%e %e %e %e %e" % (maxTime,timestep,viscosity,temperature,                                       overlapStrength))    # # EXAMPLE USAGE:# # Below is an example set up. A loop is created of positive beads and a negative# # bead is placed in the centre.# # Simulation parameters are also set (in S.I.)# # The simulation is run and the results are rendered into images. The images are# # then stitched into a video.# beads, springs = createHomoLoop(32,mass=1e-9,radius=1e-6,charge=1e-6,#                                  natLength=1.9e-6, springConst=1e-7)# negBead = createBead(position=[0,0,0],mass=1e-8,radius=1e-6,charge=-1e-2)# beads = beads + [negBead]# setSimulationParameters(10,0.05,1e-3,300,5e-14)# initialiseObjects(beads,springs)runSimulation()imageArray = renderBeadsSprings()imagesToVideo(imageArray)    